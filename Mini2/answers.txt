Name: Nickolas Westman
UCLA ID: 903996152

Collaborators: None

-------------------------------------------------------------------------------

Response to Exercise 1:

The name of the scheduling algorithm is:
First In, First Out. 
It goes through each process in order, using a modulo to wrap around.

(Exercise 2 is a coding exercise)

Response to Exercise 3:

Average turnaround time for scheduling_algorithm 0:
To turn around, we need to wait for 319 characters from each to print
1: 319 * 4 + 1 
2: 319 * 4 + 2 
3: 319 * 4 + 3 
4: 319 * 4 + 4 

Average = Total Time / #Procs = (319 * 4 * 4 + 1+2+3+4) / 4 = 1278.5 ms

Average turnaround time for scheduling_algorithm 1:
1: 320
2: 320 * 2
3: 320 * 3
4: 320 * 4

Average = 320 * (1+2+3+4) / 4 = 800 ms

Average wait time for scheduling_algorithm 0:
(0 + 1 + 2 + 3) / 4 = 1.5 ms

Average wait time for scheduling_algorithm 1:
(0 + 320 + 640 + 960) / 4 = 480 ms


Exercise 4:

Did you complete Exercise 4A, Exercise 4B, or both for extra credit?

Both, 4B is more complete. 4A works, there's currently a minor bug where it will "step down" priorities, meaning that if the priority is inverse to the thread number, it will sequentially step down to the next highest priority, rather than the highest priority possible.


Exercise 5:

When it's trying to print the 16th character, there's an interrupt that happens there. Process 4 should have control of the print there, but the scheduler yanks control away and instead Process 1 overwrites the same buffer that process 4 should be using.

tl;dr It happens in process 4 on its 5th iteration.

(Exercise 6 is a coding exercise)


Anything else you'd like us to know:

Two system calls that I added are:
priority() - sets the priority of the process
share() - sets the share of the process
Neither do anything unless the scheduling algorithm is correctly set.

Extra credit exercises:
